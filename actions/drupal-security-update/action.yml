name: 'Drupal Security Update'
description: 'Automatically update Composer dependencies with security vulnerabilities'
author: 'Phase2'

branding:
  icon: 'shield'
  color: 'blue'

inputs:
  anthropic_api_key:
    description: 'Anthropic API key for Claude'
    required: true
  github_token:
    description: 'GitHub token for creating branches and PRs (defaults to github.token)'
    required: false
    default: ${{ github.token }}
  working_directory:
    description: 'Directory containing composer.json'
    required: false
    default: '.'
  base_branch:
    description: 'Base branch for the PR'
    required: false
    default: 'main'
  dry_run:
    description: 'If true, check for vulnerabilities but do not create PR'
    required: false
    default: 'false'
  branch_prefix:
    description: 'Prefix for the created branch name (e.g., "issue/" creates "issue/autoupdate-YYYYMMDDHHMM")'
    required: false
    default: 'issue/'
  pr_reviewers:
    description: 'Comma-separated list of GitHub usernames to request review from on the created PR'
    required: false
    default: ''

  # Slack Notifications
  slack_webhook:
    description: 'Slack webhook URL for notifications (optional)'
    required: false
  slack_channel:
    description: 'Slack channel name (without #) - required if slack_webhook is set'
    required: false

outputs:
  has_vulnerabilities:
    description: 'Whether security vulnerabilities were found'
    value: ${{ steps.audit.outputs.has_vulnerabilities }}
  pr_url:
    description: 'URL of the created pull request (if any)'
    value: ${{ steps.create-pr.outputs.pull-request-url }}
  vulnerabilities_found:
    description: 'Number of vulnerabilities found'
    value: ${{ steps.audit.outputs.vulnerability_count }}

  # PR Deduplication outputs
  pr_action:
    description: 'Action taken for PR (create, skip, supersede)'
    value: ${{ steps.existing-pr.outputs.action }}
  superseded_pr:
    description: 'PR number that was superseded (if any)'
    value: ${{ steps.existing-pr.outputs.existing_pr }}

  # Slack notification output
  slack_notification_sent:
    description: 'Whether Slack notification was sent successfully'
    value: ${{ steps.slack-notify.outputs.sent }}

runs:
  using: 'composite'
  steps:
    - name: Install dependencies
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        if [ -f composer.lock ]; then
          composer install --no-interaction --no-progress
        fi

    - name: Run Composer audit
      id: audit
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        set +e
        AUDIT_OUTPUT=$(composer audit --format=json 2>/dev/null)
        AUDIT_EXIT_CODE=$?
        set -e

        echo "audit_json<<GHAAJEOF" >> $GITHUB_OUTPUT
        echo "$AUDIT_OUTPUT" >> $GITHUB_OUTPUT
        echo "GHAAJEOF" >> $GITHUB_OUTPUT

        if [ $AUDIT_EXIT_CODE -ne 0 ]; then
          VULN_COUNT=$(echo "$AUDIT_OUTPUT" | jq -r '.advisories | to_entries | map(.value | length) | add // 0')
          echo "has_vulnerabilities=true" >> $GITHUB_OUTPUT
          echo "vulnerability_count=$VULN_COUNT" >> $GITHUB_OUTPUT
          echo "::warning::Found $VULN_COUNT security vulnerabilities in Composer dependencies"
        else
          echo "has_vulnerabilities=false" >> $GITHUB_OUTPUT
          echo "vulnerability_count=0" >> $GITHUB_OUTPUT
          echo "::notice::No security vulnerabilities found"
        fi

    - name: Exit if no vulnerabilities or dry run
      if: steps.audit.outputs.has_vulnerabilities != 'true' || inputs.dry_run == 'true'
      shell: bash
      run: |
        if [ "${{ steps.audit.outputs.has_vulnerabilities }}" != "true" ]; then
          echo "No security vulnerabilities found. Exiting."
        else
          echo "Dry run mode - vulnerabilities found but not creating PR."
          echo "Vulnerabilities: ${{ steps.audit.outputs.vulnerability_count }}"
        fi

    - name: Run Claude Code for updates
      if: steps.audit.outputs.has_vulnerabilities == 'true' && inputs.dry_run != 'true'
      uses: anthropics/claude-code-action@v1
      with:
        anthropic_api_key: ${{ inputs.anthropic_api_key }}
        github_token: ${{ inputs.github_token }}
        show_full_output: true
        claude_args: |
          --allowedTools "Bash,Read,Write,Edit,Glob,Grep,WebFetch,WebSearch"
        prompt: |
          Perform a Drupal security update based on composer audit results.

          Read the instructions at ${{ github.action_path }}/instructions.md and follow them precisely.

          The composer audit found the following vulnerabilities:
          ```json
          ${{ steps.audit.outputs.audit_json }}
          ```

          Working directory: ${{ inputs.working_directory }}

          Key requirements:
          - CRITICAL: Only update packages that are DIRECT dependencies (listed in composer.json require/require-dev)
          - NEVER run composer update on transitive dependencies or composer itself
          - Before updating any package, verify it exists in composer.json with: grep -E "\"vendor/package\"" composer.json
          - Handle patch failures by searching drupal.org issue queues
          - Run validation before completing
          - Create pr_body.md with security advisory links and any patch changes
          - Create commit_message.txt with a concise commit message summarizing the updates
          - Document any transitive vulnerabilities that require upstream fixes
          - DO NOT stage or commit changes

    - name: Check for existing security PRs
      if: steps.audit.outputs.has_vulnerabilities == 'true' && inputs.dry_run != 'true'
      id: existing-pr
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        set -euo pipefail

        LABEL_NAME="drupal-security-update"
        API_HEADERS=(
          -H "Authorization: Bearer $GITHUB_TOKEN"
          -H "Accept: application/vnd.github+json"
          -H "X-GitHub-Api-Version: 2022-11-28"
        )

        # Find open PRs with the label on the target base branch (pagination-safe).
        QUERY="repo:${{ github.repository }} is:pr is:open base:${{ inputs.base_branch }} label:${LABEL_NAME}"
        ENCODED_QUERY=$(printf '%s' "$QUERY" | jq -sRr @uri)
        SEARCH_JSON=$(curl -sS "${API_HEADERS[@]}" \
          "https://api.github.com/search/issues?q=$ENCODED_QUERY&per_page=100") || {
          echo "GitHub search failed; creating new PR"
          echo "action=create" >> $GITHUB_OUTPUT
          exit 0
        }

        TOTAL_COUNT=$(echo "$SEARCH_JSON" | jq -r '.total_count // 0')
        if [ "$TOTAL_COUNT" = "0" ] || [ "$TOTAL_COUNT" = "null" ]; then
          echo "No existing security PRs found with label '$LABEL_NAME'"
          echo "action=create" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Found $TOTAL_COUNT existing security PR(s) with label '$LABEL_NAME'"

        # Select the most recent candidate PR from this repo (ignore fork PRs).
        PR_NUMBER=""
        PR_BRANCH=""

        CANDIDATE_NUMBERS=$(echo "$SEARCH_JSON" | jq -r '.items | sort_by(.created_at) | reverse | .[].number')
        for N in $CANDIDATE_NUMBERS; do
          PR_JSON=$(curl -sS "${API_HEADERS[@]}" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$N" 2>/dev/null) || continue

          HEAD_REPO=$(echo "$PR_JSON" | jq -r '.head.repo.full_name // empty')
          if [ "$HEAD_REPO" != "${{ github.repository }}" ]; then
            continue
          fi

          PR_NUMBER="$N"
          PR_BRANCH=$(echo "$PR_JSON" | jq -r '.head.ref // empty')
          break
        done

        if [ -z "$PR_NUMBER" ] || [ -z "$PR_BRANCH" ]; then
          echo "No same-repo security PRs found (fork PRs are ignored)"
          echo "action=create" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Checking PR #$PR_NUMBER on branch $PR_BRANCH"
        echo "existing_pr=$PR_NUMBER" >> $GITHUB_OUTPUT

        # Fetch the existing PR branch and base branch (needed for diffs).
        git fetch origin "${{ inputs.base_branch }}" "$PR_BRANCH" 2>/dev/null || {
          echo "Could not fetch PR branch, creating new PR"
          echo "action=create" >> $GITHUB_OUTPUT
          exit 0
        }

        # Get list of files changed in current staged changes
        mapfile -t CURRENT_FILES < <(git diff --cached --name-only | LC_ALL=C sort -u)

        # Get list of files changed in existing PR (compared to base)
        mapfile -t EXISTING_FILES < <(git diff --name-only "origin/${{ inputs.base_branch }}...origin/$PR_BRANCH" 2>/dev/null | LC_ALL=C sort -u || true)

        echo "Current changes files: ${CURRENT_FILES[*]:-(none)}"
        echo "Existing PR files: ${EXISTING_FILES[*]:-(none)}"

        CURRENT_FILES_TEXT=$(printf '%s\n' "${CURRENT_FILES[@]}")
        EXISTING_FILES_TEXT=$(printf '%s\n' "${EXISTING_FILES[@]}")

        # Compare file lists
        if [ "$CURRENT_FILES_TEXT" = "$EXISTING_FILES_TEXT" ]; then
          # Same files - check if content is identical (portable hashing; avoids md5sum differences).
          EXISTING_HASH=$(git diff "origin/${{ inputs.base_branch }}...origin/$PR_BRANCH" 2>/dev/null | openssl dgst -sha256 -r | cut -d' ' -f1)
          CURRENT_HASH=$(git diff --cached | openssl dgst -sha256 -r | cut -d' ' -f1)

          if [ "$EXISTING_HASH" = "$CURRENT_HASH" ]; then
            echo "Changes are identical to existing PR #$PR_NUMBER"
            echo "action=skip" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi

        # Check if current is a safe superset:
        # - Includes all files from existing PR
        # - AND overlapping file diffs match exactly (so we don't close a PR with different changes)
        if [ "${#EXISTING_FILES[@]}" -gt 0 ]; then
          MISSING_FROM_CURRENT=$(comm -23 <(printf '%s\n' "${EXISTING_FILES[@]}") <(printf '%s\n' "${CURRENT_FILES[@]}") | head -1 || true)

          if [ -z "$MISSING_FROM_CURRENT" ]; then
            EXISTING_OVERLAP_HASH=$(git diff "origin/${{ inputs.base_branch }}...origin/$PR_BRANCH" -- "${EXISTING_FILES[@]}" 2>/dev/null | openssl dgst -sha256 -r | cut -d' ' -f1)
            CURRENT_OVERLAP_HASH=$(git diff --cached -- "${EXISTING_FILES[@]}" | openssl dgst -sha256 -r | cut -d' ' -f1)

            if [ "$EXISTING_OVERLAP_HASH" = "$CURRENT_OVERLAP_HASH" ]; then
              echo "Current changes safely supersede existing PR #$PR_NUMBER (overlapping diffs match)"
              echo "action=supersede" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "Current changes include existing files but differ in overlapping diffs; creating new PR"
          fi
        fi

        # Changes are different - create new PR
        echo "Changes differ from existing PR - creating new PR"
        echo "action=create" >> $GITHUB_OUTPUT

    - name: Handle existing PR (supersede)
      if: steps.existing-pr.outputs.action == 'supersede'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        PR_NUMBER=${{ steps.existing-pr.outputs.existing_pr }}

        echo "Superseding PR #$PR_NUMBER with newer security update"

        # Add comment to existing PR
        curl -s -X POST \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/issues/$PR_NUMBER/comments" \
          -d '{"body": "This PR has been superseded by a newer security update that includes additional fixes. Closing in favor of the new PR."}'

        # Close existing PR
        curl -s -X PATCH \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER" \
          -d '{"state": "closed"}'

        echo "::notice::Closed superseded PR #$PR_NUMBER"

    - name: Skip if identical
      if: steps.existing-pr.outputs.action == 'skip'
      shell: bash
      run: |
        echo "::notice::Skipping PR creation - identical to existing PR #${{ steps.existing-pr.outputs.existing_pr }}"
        echo "Existing PR: https://github.com/${{ github.repository }}/pull/${{ steps.existing-pr.outputs.existing_pr }}"
        exit 0

    - name: Prepare PR metadata
      if: steps.audit.outputs.has_vulnerabilities == 'true' && inputs.dry_run != 'true'
      id: prepare-pr
      shell: bash
      working-directory: ${{ inputs.working_directory }}
      run: |
        # Generate branch name with prefix
        BRANCH_NAME="${{ inputs.branch_prefix }}autoupdate-$(date +%Y%m%d%H%M)"
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

        # Generate PR title with date
        PR_TITLE="Security: Drupal security updates - $(date +%Y-%m-%d)"
        echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT

        # Read PR body from Claude's output (if exists) then remove it so it's not committed
        if [ -f pr_body.md ]; then
          {
            echo "pr_body<<GHPREOF"
            cat pr_body.md
            echo "GHPREOF"
          } >> $GITHUB_OUTPUT
          rm pr_body.md
        else
          {
            echo "pr_body<<GHPREOF"
            echo "Automated security update for Drupal Composer dependencies."
            echo ""
            echo "This PR addresses ${{ steps.audit.outputs.vulnerability_count }} security vulnerabilities found by \`composer audit\`."
            echo "GHPREOF"
          } >> $GITHUB_OUTPUT
        fi

        # Read commit message from Claude's output (if exists) then remove it so it's not committed
        if [ -f commit_message.txt ]; then
          {
            echo "commit_message<<GHCMEOF"
            cat commit_message.txt
            echo "GHCMEOF"
          } >> $GITHUB_OUTPUT
          rm commit_message.txt
        else
          {
            echo "commit_message<<GHCMEOF"
            echo "Security update: Drupal Composer dependencies"
            echo ""
            echo "Automated security update performed by Drupal Security Updates action."
            echo "Vulnerabilities addressed: ${{ steps.audit.outputs.vulnerability_count }}"
            echo "GHCMEOF"
          } >> $GITHUB_OUTPUT
        fi

    - name: Create Pull Request
      if: steps.audit.outputs.has_vulnerabilities == 'true' && inputs.dry_run != 'true'
      id: create-pr
      uses: peter-evans/create-pull-request@v7
      with:
        token: ${{ inputs.github_token }}
        branch: ${{ steps.prepare-pr.outputs.branch_name }}
        base: ${{ inputs.base_branch }}
        title: ${{ steps.prepare-pr.outputs.pr_title }}
        body: ${{ steps.prepare-pr.outputs.pr_body }}
        commit-message: ${{ steps.prepare-pr.outputs.commit_message }}
        reviewers: ${{ inputs.pr_reviewers }}
        committer: drupal-security-update[bot] <drupal-security-update@users.noreply.github.com>
        author: drupal-security-update[bot] <drupal-security-update@users.noreply.github.com>

    - name: Send Slack notification
      id: slack-notify
      if: steps.create-pr.outputs.pull-request-url != '' && inputs.slack_webhook != '' && inputs.slack_channel != ''
      shell: bash
      env:
        SLACK_WEBHOOK: ${{ inputs.slack_webhook }}
      run: |
        # Build Slack message payload
        CHANNEL="${{ inputs.slack_channel }}"
        PR_URL="${{ steps.create-pr.outputs.pull-request-url }}"
        VULN_COUNT="${{ steps.audit.outputs.vulnerability_count }}"
        REPO="${{ github.repository }}"

        # Construct the payload
        PAYLOAD=$(cat <<'EOFPAYLOAD'
        {
          "channel": "#CHANNEL_PLACEHOLDER",
          "username": "Drupal Security Bot",
          "icon_emoji": ":shield:",
          "attachments": [
            {
              "color": "warning",
              "title": "Drupal Security Update Required",
              "title_link": "PR_URL_PLACEHOLDER",
              "text": "A new security update PR has been created for *REPO_PLACEHOLDER*",
              "fields": [
                {
                  "title": "Vulnerabilities Found",
                  "value": "VULN_COUNT_PLACEHOLDER",
                  "short": true
                },
                {
                  "title": "Action Required",
                  "value": "Review and merge PR",
                  "short": true
                }
              ],
              "footer": "Drupal Security Update Action"
            }
          ]
        }
        EOFPAYLOAD
        )

        # Replace placeholders
        PAYLOAD=$(echo "$PAYLOAD" | sed "s|CHANNEL_PLACEHOLDER|$CHANNEL|g")
        PAYLOAD=$(echo "$PAYLOAD" | sed "s|PR_URL_PLACEHOLDER|$PR_URL|g")
        PAYLOAD=$(echo "$PAYLOAD" | sed "s|REPO_PLACEHOLDER|$REPO|g")
        PAYLOAD=$(echo "$PAYLOAD" | sed "s|VULN_COUNT_PLACEHOLDER|$VULN_COUNT|g")

        # Send to Slack
        RESPONSE=$(curl -s -X POST \
          -H "Content-Type: application/json" \
          -d "$PAYLOAD" \
          "$SLACK_WEBHOOK")

        if [ "$RESPONSE" = "ok" ]; then
          echo "sent=true" >> $GITHUB_OUTPUT
          echo "::notice::Slack notification sent successfully"
        else
          echo "sent=false" >> $GITHUB_OUTPUT
          echo "::warning::Slack notification may have failed: $RESPONSE"
        fi

    - name: Report PR status
      if: steps.audit.outputs.has_vulnerabilities == 'true' && inputs.dry_run != 'true'
      shell: bash
      run: |
        if [ -n "${{ steps.create-pr.outputs.pull-request-url }}" ]; then
          echo "::notice::Created PR: ${{ steps.create-pr.outputs.pull-request-url }}"
        else
          echo "::warning::Vulnerabilities found but no changes were made (packages may already be at latest versions)"
        fi
